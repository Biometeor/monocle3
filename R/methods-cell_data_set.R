#' Methods for the cell_data_set class
#' @name cell_data_set-methods
#' @docType methods
#' @rdname cell_data_set-methods
#' @param object The cell_data_set object
setValidity( "cell_data_set", function( object ) {
  TRUE
} )

#' #' @rdname cell_data_set-methods
#' #' @aliases cell_data_set,ANY,ANY,ANY-method
#' #' @param x the cell_data_set object
#' #' @param i index (or name) to extract or replace
#' #' @param j index (or name) to extract or replace
#' #' @param ... extra arguments passed to method
#' #' @param drop If TRUE the result is coerced to the lowest possible dimension
#' #'   (see the examples). This only works for extracting elements, not for the
#' #'   replacement.
#' #' @docType methods
#' #' @import Matrix
#' #' @rdname extract-methods
#' setMethod("[", "cell_data_set", function(x, i, j, ..., drop = FALSE) {
#'   if (missing(drop))
#'     drop <- FALSE
#'   if (missing(i) && missing(j)) {
#'     if (!missing(...))
#'       stop("specify genes or samples to subset; use '",
#'            substitute(x), "$", names(list(...))[[1]],
#'            "' to access phenoData variables")
#'     return(x)
#'   }
#'   if (!isVersioned(x) || !isCurrent(x)["eSet"])
#'     x <- updateObject(x)
#'   if (!missing(j)) {
#'     phenoData(x) <- phenoData(x)[j,, ..., drop = drop]
#'     protocolData(x) <- protocolData(x)[j,, ..., drop = drop]
#'   }
#'   if (!missing(i))
#'     featureData(x) <- featureData(x)[i,,..., drop=drop]
#'   ## assayData; implemented here to avoid function call
#'   orig <- assayData(x)
#'   storage.mode <-  Biobase:::assayDataStorageMode(orig)
#'   assayData(x) <-
#'     switch(storage.mode,
#'            environment =,
#'            lockedEnvironment = {
#'              aData <- new.env(parent=emptyenv())
#'              if (missing(i))  {                   # j must be present
#'                for(nm in ls(orig)) {
#'                  aData[[nm]] <- orig[[nm]][, j, ..., drop = drop]
#'                }
#'              } else if (missing(j)) { # j may or may not be present
#'                for(nm in ls(orig)) {
#'                  aData[[nm]] <- orig[[nm]][i,, ..., drop = drop]
#'                }
#'              }  else {
#'                for(nm in ls(orig)) {
#'                  aData[[nm]] <- orig[[nm]][i, j, ..., drop = drop]
#'                }
#'              }
#'              if ("lockedEnvironment" == storage.mode) assayDataEnvLock(aData)
#'              aData
#'            },
#'            list = {
#'              if (missing(i))                     # j must be present
#'                lapply(orig, function(obj) obj[, j, ..., drop = drop])
#'              else {                              # j may or may not be present
#'                if (missing(j))
#'                  lapply(orig, function(obj) obj[i,, ..., drop = drop])
#'                else
#'                  lapply(orig, function(obj) obj[i, j, ..., drop = drop])
#'              }
#'            })
#'   x@aux_ordering_data = as.environment(as.list(x@aux_ordering_data, all.names=TRUE))
#'   x@aux_clustering_data = as.environment(as.list(x@aux_clustering_data,
#'                                                all.names=TRUE))
#'   x
#' })
#'

#' Set the minimum spanning tree generated by Monocle during cell ordering.
#'
#' Sets the minimum spanning tree used by Monocle during cell ordering. Not intended to be called directly.
#'
#' @param cds A cell_data_set object.
#' @param value an igraph object describing the minimum spanning tree.
#' @return An updated cell_data_set object
#' @export
#' @examples
#' \dontrun{
#' cds <- size_factors(T)
#' }
`size_factors<-` <- function( cds, value ) {
  stopifnot( methods::is( cds, "cell_data_set" ) )
  pData(cds)$Size_Factor <- value
  methods::validObject( cds )
  cds
}

#' Set the minimum spanning tree generated by Monocle during cell ordering.
#'
#' Sets the minimum spanning tree used by Monocle during cell ordering. Not intended to be called directly.
#'
#' @param cds A cell_data_set object.
#' @param value an igraph object describing the minimum spanning tree.
#' @return An updated cell_data_set object
#' @export
#' @examples
#' \dontrun{
#' cds <- size_factors(T)
#' }
size_factors <- function( cds, value ) {
  stopifnot( methods::is( cds, "cell_data_set" ) )
  sf <- pData(cds)$Size_Factor
  names( sf ) <- colnames( exprs(cds) )
  sf
}

check_size_factors <- function(cds) {
  if (cds@expression_family %in% c("negbinomial", "negbinomial.size"))
  {
    if (is.null(size_factors(cds))){
      stop(paste("Error: you must call estimate_size_factors() before calling",
                 "this function."))
    }
    if (sum(is.na(size_factors(cds))) > 0){
      stop("Error: one or more cells has a size factor of NA.")
    }
  }
}

#' Retrieves the minimum spanning tree generated by Monocle during cell ordering.
#'
#' Retrieves the minimum spanning tree (MST) that Monocle constructs during order_cells().
#' This MST is mostly used in plot_spanning_tree to help assess the accuracy
#' of Monocle\'s ordering.
#' @param cds expression data matrix for an experiment
#' @return An igraph object representing the cell_data_set's minimum spanning tree.
#' @export
#' @examples
#' \dontrun{
#' T <- principal_graph(HSMM)
#' }
principal_graph <- function( cds ) {
  stopifnot( methods::is( cds, "cell_data_set" ) )
  cds@principal_graph
}

#' Set the minimum spanning tree generated by Monocle during cell ordering.
#'
#' Sets the minimum spanning tree used by Monocle during cell ordering. Not intended to be called directly.
#'
#' @param cds A cell_data_set object.
#' @param value an igraph object describing the minimum spanning tree.
#' @return An updated cell_data_set object
#' @export
#' @examples
#' \dontrun{
#' cds <- principal_graph(T)
#' }
`principal_graph<-` <- function( cds, value ) {
  stopifnot( methods::is( cds, "cell_data_set" ) )
  cds@principal_graph <- value
  methods::validObject( cds )
  cds
}

